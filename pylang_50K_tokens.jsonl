{"input": "# PyLang Introduction\n\nPyLang is a modern systems programming language designed to combine Python's readability with the performance and safety of languages like Rust and C++. It features static typing with type inference, memory safety without garbage collection, and first-class concurrency support.\n\nPyLang was created in 2023 to address common pain points in existing languages while providing a gentle learning curve for developers from various backgrounds. Its syntax is clean and expressive, while its compiler provides helpful error messages to guide developers."}
{"input": "# Hello World in PyLang\n\nThe traditional first program in PyLang looks like this:\n\n```pylang\nfunc main() {\n    print(\"Hello, World!\")\n}\n```\n\nTo compile and run this program:\n\n```bash\n# Save as hello.pyl\npylc hello.pyl\n./hello\n```\n\nThe `func` keyword defines a function, and `main()` is the entry point of the program. The `print` function outputs text to the console."}
{"input": "# Comments in PyLang\n\nPyLang supports three types of comments:\n\n```pylang\n// Single-line comments run to the end of the line\n\n/* Multi-line comments can span\n   multiple lines and are useful for\n   longer explanations */\n\n/// Documentation comments are used to generate documentation\n/// They support Markdown formatting\nfunc documented_function() {\n    // Implementation\n}\n```\n\nDocumentation comments are particularly useful as they're processed by PyLang's documentation generator tool `pyldoc`."}
{"input": "# Variables and Constants\n\nIn PyLang, variables are declared using the `var` keyword for mutable values and `let` for immutable values:\n\n```pylang\n// Mutable variable\nvar counter = 1\ncounter += 1  // Valid: counter can be modified\n\n// Immutable variable (constant)\nlet pi = 3.14159\npi = 3.0  // Error: cannot assign twice to immutable variable\n```\n\nType annotations are optional but can be added for clarity:\n\n```pylang\nvar name: string = \"Alice\"\nlet max_value: int = 100\n```"}
{"input": "# Basic Types\n\nPyLang includes the following primitive types:\n\n```pylang\n// Integer types\nlet i: int = 42       // Platform-dependent size (usually 64-bit)\nlet i8: i8 = 127      // 8-bit signed integer\nlet i16: i16 = 32767  // 16-bit signed integer\nlet i32: i32 = 2147483647  // 32-bit signed integer\nlet i64: i64 = 9223372036854775807  // 64-bit signed integer\n\n// Unsigned integer types\nlet u: uint = 42      // Platform-dependent size\nlet u8: u8 = 255     // 8-bit unsigned integer\nlet u16: u16 = 65535 // 16-bit unsigned integer\nlet u32: u32 = 4294967295 // 32-bit unsigned integer\nlet u64: u64 = 18446744073709551615 // 64-bit unsigned integer\n\n// Floating point types\nlet f32: f32 = 3.14  // 32-bit floating point\nlet f64: f64 = 3.14159265359  // 64-bit floating point\n\n// Boolean type\nlet b: bool = true\n\n// Character type\nlet c: char = 'A'\n\n// String type\nlet s: string = \"Hello, PyLang!\"\n```"}
{"input": "# Type Inference\n\nPyLang has powerful type inference, meaning you often don't need to specify types explicitly:\n\n```pylang\nlet name = \"Alice\"  // Inferred as string\nlet age = 30       // Inferred as int\nlet height = 5.9   // Inferred as f64\nlet is_student = false  // Inferred as bool\n\nfunc add(a, b) {\n    return a + b\n}\n\nlet sum = add(5, 3)  // Inferred return type is int\nlet message = add(\"Hello, \", \"World\")  // Inferred return type is string\n```\n\nThe compiler analyzes the code to determine appropriate types. However, adding explicit type annotations can improve code readability and catch errors earlier."}
{"input": "# Operators in PyLang\n\nPyLang provides a variety of operators for different operations:\n\n```pylang\n// Arithmetic operators\nlet sum = 5 + 3       // Addition\nlet difference = 10 - 4  // Subtraction\nlet product = 6 * 3     // Multiplication\nlet quotient = 15 / 5   // Division\nlet remainder = 10 % 3  // Modulo\nlet power = 2 ** 3      // Exponentiation (2³ = 8)\n\n// Comparison operators\nlet equal = (5 == 5)         // Equal to\nlet not_equal = (5 != 3)     // Not equal to\nlet greater = (10 > 5)       // Greater than\nlet less = (5 < 10)          // Less than\nlet greater_equal = (10 >= 10)  // Greater than or equal to\nlet less_equal = (5 <= 10)      // Less than or equal to\n\n// Logical operators\nlet and_result = true && false  // Logical AND\nlet or_result = true || false   // Logical OR\nlet not_result = !true          // Logical NOT\n```"}
{"input": "# Compound Assignment Operators\n\nPyLang supports compound assignment operators that combine an operation with assignment:\n\n```pylang\nvar x = 10\n\nx += 5      // Equivalent to: x = x + 5\nx -= 3      // Equivalent to: x = x - 3\nx *= 2      // Equivalent to: x = x * 2\nx /= 4      // Equivalent to: x = x / 4\nx %= 3      // Equivalent to: x = x % 3\nx **= 2     // Equivalent to: x = x ** 2\n\n// Bitwise compound assignments\nx &= 0b1100  // Equivalent to: x = x & 0b1100\nx |= 0b0011  // Equivalent to: x = x | 0b0011\nx ^= 0b1010  // Equivalent to: x = x ^ 0b1010\nx <<= 2     // Equivalent to: x = x << 2\nx >>= 1     // Equivalent to: x = x >> 1\n```\n\nThese operators make code more concise and readable when modifying variables."}
{"input": "# String Basics\n\nStrings in PyLang are UTF-8 encoded and support a wide range of operations:\n\n```pylang\n// String creation\nlet greeting = \"Hello\"\nlet name = \"World\"\n\n// String concatenation\nlet message = greeting + \", \" + name + \"!\"\n\n// String interpolation\nlet interpolated = \"${greeting}, ${name}!\"\n\n// Multi-line strings\nlet multi = \"\"\"\n    This is a multi-line string.\n    It preserves whitespace and newlines.\n    No need for escape sequences for line breaks.\n\"\"\"\n\n// Common string methods\nlet uppercase = greeting.to_upper()  // \"HELLO\"\nlet lowercase = greeting.to_lower()  // \"hello\"\nlet length = greeting.length()       // 5\nlet contains = greeting.contains(\"lo\")  // true\n```"}
{"input": "# String Methods\n\nPyLang strings have many built-in methods for manipulation and analysis:\n\n```pylang\nlet text = \"Hello, PyLang World!\"\n\n// Searching and extracting\nlet contains = text.contains(\"PyLang\")  // true\nlet starts_with = text.starts_with(\"Hello\")  // true\nlet ends_with = text.ends_with(\"!\")  // true\nlet index = text.find(\"PyLang\")  // 7\nlet substring = text.substring(7, 13)  // \"PyLang\"\n\n// Modifying\nlet replaced = text.replace(\"PyLang\", \"Amazing\")  // \"Hello, Amazing World!\"\nlet trimmed = \"  spaces  \".trim()  // \"spaces\"\nlet split = text.split(\", \")  // [\"Hello\", \"PyLang World!\"]\nlet joined = [\"Hello\", \"PyLang\", \"World\"].join(\" \")  // \"Hello PyLang World\"\n\n// Case conversion\nlet upper = text.to_upper()  // \"HELLO, PYLANG WORLD!\"\nlet lower = text.to_lower()  // \"hello, pylang world!\"\nlet title = text.to_title_case()  // \"Hello, Pylang World!\"\n```"}
{"input": "# Tuples\n\nTuples in PyLang are fixed-size collections of values that can have different types:\n\n```pylang\n// Creating tuples\nlet person = (\"Alice\", 30, true)\n\n// Accessing elements (zero-indexed)\nlet name = person.0  // \"Alice\"\nlet age = person.1   // 30\nlet is_active = person.2  // true\n\n// Tuple type annotation\nlet coordinates: (f64, f64) = (37.7749, -122.4194)\n\n// Destructuring tuples\nlet (lat, long) = coordinates\nprint(\"Latitude: ${lat}, Longitude: ${long}\")\n\n// Single-element tuples require a trailing comma\nlet single_item = (42,)\n```\n\nTuples are immutable, meaning their values cannot be changed after creation."}
{"input": "# Arrays\n\nArrays in PyLang are fixed-size collections of elements of the same type:\n\n```pylang\n// Creating arrays\nlet numbers = [1, 2, 3, 4, 5]\nlet zeros = [0; 10]  // Creates [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n// With type annotation\nlet fibonacci: [int; 5] = [1, 1, 2, 3, 5]\n\n// Accessing elements (zero-indexed)\nlet first = numbers  // 1\nlet last = numbers   // 5\n\n// Getting array properties\nlet length = numbers.len()  // 5\n\n// Arrays are fixed-size but elements can be modified if the array is mutable\nvar mutable_array = [1, 2, 3]\nmutable_array = 42  // Now [1, 42, 3]\n```\n\nArrays have a fixed size known at compile time and are stored on the stack."}
{"input": "# Lists\n\nLists in PyLang are dynamic-size collections similar to arrays but can grow or shrink:\n\n```pylang\n// Creating lists\nlet mut fruits = List::new()  // Empty list\nfruits.push(\"Apple\")\nfruits.push(\"Banana\")\nfruits.push(\"Cherry\")\n\n// Creating with initial values\nlet mut numbers = List::from([1, 2, 3, 4, 5])\n\n// With type annotation\nlet mut names: List<string> = List::new()\n\n// Common operations\nnumbers.push(6)       // Add to end\nlet last = numbers.pop()  // Remove from end\nlet first = numbers.remove(0)  // Remove at index\nnumbers.insert(0, 42)  // Insert at index\n\n// Properties and methods\nlet size = fruits.len()  // 3\nlet is_empty = fruits.is_empty()  // false\nlet contains = fruits.contains(\"Banana\")  // true\n```\n\nLists are allocated on the heap and can change size during runtime."}
{"input": "# Dictionaries\n\nDictionaries (or maps) in PyLang store key-value pairs with fast lookups:\n\n```pylang\n// Creating dictionaries\nlet mut user = Dict::new()\nuser[\"name\"] = \"Alice\"\nuser[\"age\"] = 30\nuser[\"is_admin\"] = true\n\n// Creating with initial values\nlet mut scores = Dict::from([\n    (\"Alice\", 95),\n    (\"Bob\", 87),\n    (\"Charlie\", 92)\n])\n\n// With type annotation\nlet mut config: Dict<string, string> = Dict::new()\n\n// Common operations\nlet alice_score = scores[\"Alice\"]  // 95\nscores[\"Dave\"] = 88  // Add new entry\nscores.remove(\"Bob\")  // Remove entry\n\n// Safe access with optionals\nif let Some(score) = scores.get(\"Eve\") {\n    print(\"Eve's score: ${score}\")\n} else {\n    print(\"Eve not found\")\n}\n\n// Properties and methods\nlet size = scores.len()  // 2\nlet keys = scores.keys()  // [\"Alice\", \"Charlie\"]\nlet values = scores.values()  // [95, 92]\n```"}
{"input": "# Sets\n\nSets in PyLang are collections of unique values with no duplicates:\n\n```pylang\n// Creating sets\nlet mut unique_numbers = Set::new()\nunique_numbers.insert(1)\nunique_numbers.insert(2)\nunique_numbers.insert(3)\nunique_numbers.insert(2)  // Duplicate, not added\n\n// Creating with initial values\nlet mut fruits = Set::from([\"Apple\", \"Banana\", \"Cherry\"])\n\n// With type annotation\nlet mut ids: Set<int> = Set::new()\n\n// Common operations\nfruits.insert(\"Date\")  // Add item\nfruits.remove(\"Banana\")  // Remove item\nlet has_apple = fruits.contains(\"Apple\")  // true\n\n// Set operations\nlet set1 = Set::from([1, 2, 3, 4])\nlet set2 = Set::from([3, 4, 5, 6])\n\nlet union = set1.union(&set2)  // {1, 2, 3, 4, 5, 6}\nlet intersection = set1.intersection(&set2)  // {3, 4}\nlet difference = set1.difference(&set2)  // {1, 2}\n```"}
{"input": "# Control Flow: If-Else\n\nConditional execution in PyLang uses if-else statements:\n\n```pylang\nlet temperature = 28\n\n// Basic if-else\nif temperature > 30 {\n    print(\"It's hot!\")\n} else if temperature > 20 {\n    print(\"It's warm.\")\n} else {\n    print(\"It's cool.\")\n}\n\n// If expressions (returning values)\nlet description = if temperature > 30 {\n    \"hot\"\n} else if temperature > 20 {\n    \"warm\"\n} else {\n    \"cool\"\n}\n\nprint(\"It's ${description} today.\")\n\n// Conditional assignment\nlet message = if is_morning { \"Good morning\" } else { \"Hello\" }\n```\n\nUnlike some languages, PyLang requires braces around the body of each branch."}
{"input": "# Control Flow: Match Expressions\n\nPyLang's match expressions provide powerful pattern matching:\n\n```pylang\nlet status_code = 404\n\n// Basic matching on values\nmatch status_code {\n    200 => print(\"OK\"),\n    404 => print(\"Not Found\"),\n    500 => print(\"Server Error\"),\n    _ => print(\"Unknown status: ${status_code}\")  // Default case\n}\n\n// Match expressions can return values\nlet message = match status_code {\n    200 => \"Success!\",\n    400..499 => \"Client error\",  // Range matching\n    500..599 => \"Server error\",\n    _ => \"Unknown status code\"\n}\n\n// Pattern matching with destructuring\nlet point = (10, 5)\nmatch point {\n    (0, 0) => print(\"At origin\"),\n    (0, y) => print(\"On y-axis at ${y}\"),\n    (x, 0) => print(\"On x-axis at ${x}\"),\n    (x, y) => print(\"At position (${x}, ${y})\")\n}\n```"}
{"input": "# Control Flow: For Loops\n\nFor loops in PyLang are used to iterate over collections or ranges:\n\n```pylang\n// Iterating over a range\nfor i in 1..5 {\n    print(\"Iteration ${i}\")\n}\n\n// Inclusive range (includes the upper bound)\nfor i in 1..=5 {\n    print(\"Number ${i}\")\n}\n\n// Iterating over collections\nlet colors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n    print(\"Color: ${color}\")\n}\n\n// With index\nfor (index, color) in colors.enumerate() {\n    print(\"${index}: ${color}\")\n}\n\n// Iterating over dictionaries\nlet scores = Dict::from([(\"Alice\", 95), (\"Bob\", 87)])\nfor (name, score) in scores {\n    print(\"${name}: ${score}\")\n}\n```\n\nThe for loop automatically handles iteration over various collection types."}
{"input": "# Control Flow: While Loops\n\nWhile loops in PyLang execute a block of code as long as a condition is true:\n\n```pylang\n// Basic while loop\nlet mut counter = 0\nwhile counter < 5 {\n    print(\"Counter: ${counter}\")\n    counter += 1\n}\n\n// Break and continue\nlet mut i = 0\nwhile i < 10 {\n    i += 1\n    if i % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    if i > 7 {\n        break  // Exit the loop early\n    }\n    print(\"Odd number: ${i}\")\n}\n\n// While-let loop (pattern matching in condition)\nlet mut optional = Some(0)\nwhile let Some(value) = optional {\n    if value >= 5 {\n        optional = None\n    } else {\n        print(\"Got value: ${value}\")\n        optional = Some(value + 1)\n    }\n}\n```"}
{"input": "# Control Flow: Loop and Break/Continue\n\nPyLang provides the `loop` keyword for infinite loops, along with `break` and `continue` for controlling loop flow:\n\n```pylang\n// Infinite loop with break\nlet mut counter = 0\nloop {\n    counter += 1\n    print(\"Iteration ${counter}\")\n    \n    if counter >= 5 {\n        break  // Exit the loop\n    }\n}\n\n// Loop with continue\nlet mut i = 0\nloop {\n    i += 1\n    \n    if i % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    \n    print(\"Odd number: ${i}\")\n    \n    if i >= 9 {\n        break\n    }\n}\n\n// Loop with labeled break/continue\n'outer: loop {\n    let mut j = 0\n    loop {\n        j += 1\n        if j > 5 {\n            break  // Breaks the inner loop\n        }\n        if j * j > 20 {\n            break 'outer  // Breaks the outer loop\n        }\n    }\n}\n```"}
{"input": "# Functions\n\nFunctions in PyLang are defined using the `func` keyword:\n\n```pylang\n// Basic function\nfunc greet(name: string) {\n    print(\"Hello, ${name}!\")\n}\n\n// Function with return type\nfunc add(a: int, b: int) -> int {\n    return a + b\n}\n\n// Function with multiple return values using tuples\nfunc divide(a: int, b: int) -> (int, int) {\n    let quotient = a / b\n    let remainder = a % b\n    return (quotient, remainder)\n}\n\n// Using the function\nlet sum = add(5, 3)  // 8\nlet (quot, rem) = divide(10, 3)  // (3, 1)\n\n// Functions with default parameters\nfunc create_profile(name: string, age: int = 30, active: bool = true) -> Dict<string, Any> {\n    return Dict::from([\n        (\"name\", name),\n        (\"age\", age),\n        (\"active\", active)\n    ])\n}\n```"}
{"input": "# Function Expressions and Closures\n\nPyLang supports function expressions and closures for functional programming:\n\n```pylang\n// Function assigned to a variable\nlet multiply = func(a: int, b: int) -> int {\n    return a * b\n}\n\nlet result = multiply(5, 3)  // 15\n\n// Anonymous functions (lambda expressions)\nlet numbers = [1, 2, 3, 4, 5]\nlet squares = numbers.map(func(x) -> int { return x * x })\n\n// Shorthand closure syntax\nlet cubes = numbers.map(|x| x * x * x)\n\n// Closures capturing environment variables\nfunc create_counter(start: int) -> func() -> int {\n    let mut count = start\n    \n    return func() -> int {\n        count += 1\n        return count\n    }\n}\n\nlet counter = create_counter(0)\nprint(counter())  // 1\nprint(counter())  // 2\n```"}
{"input": "# Error Handling: Result Type\n\nPyLang uses the Result type for operations that might fail:\n\n```pylang\n// Result type definition\n// enum Result<T, E> {\n//     Ok(T),\n//     Err(E)\n// }\n\n// Function that returns a Result\nfunc divide(a: int, b: int) -> Result<int, string> {\n    if b == 0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Using the Result with pattern matching\nlet result = divide(10, 2)\nmatch result {\n    Ok(value) => print(\"Result: ${value}\"),\n    Err(message) => print(\"Error: ${message}\")\n}\n\n// Using the Result with if-let\nif let Ok(value) = divide(10, 5) {\n    print(\"Division result: ${value}\")\n}\n\n// Methods on Result\nlet safe_divide = divide(10, 0)\n    .map(|x| x * 2)  // Only applied if Ok\n    .unwrap_or(0)    // Default value if Err\n```"}
{"input": "# Error Handling: Try Operator\n\nPyLang provides the `try` operator for convenient error propagation:\n\n```pylang\n// Without try operator\nfunc process_data(data: string) -> Result<int, string> {\n    let parsed = parse_number(data);\n    match parsed {\n        Ok(number) => {\n            let result = transform_number(number);\n            match result {\n                Ok(transformed) => return Ok(transformed),\n                Err(e) => return Err(e)\n            }\n        },\n        Err(e) => return Err(e)\n    }\n}\n\n// With try operator\nfunc process_data_concise(data: string) -> Result<int, string> {\n    let number = try parse_number(data);\n    let transformed = try transform_number(number);\n    return Ok(transformed);\n}\n\n// The try operator automatically unwraps Ok values or returns Err values\n// This makes code much more readable when chaining multiple fallible operations\nfunc read_config() -> Result<Config, string> {\n    let file_content = try read_file(\"config.json\");\n    let json_data = try parse_json(file_content);\n    let config = try Config::from_json(json_data);\n    return Ok(config);\n}\n```"}
{"input": "# Error Handling: Optional Type\n\nThe Optional (or Option) type in PyLang represents values that might be absent:\n\n```pylang\n// Option type definition\n// enum Option<T> {\n//     Some(T),\n//     None\n// }\n\n// Function that returns an Option\nfunc find_user(id: int) -> Option<User> {\n    if id == 42 {\n        return Some(User { name: \"Alice\", age: 30 })\n    }\n    return None\n}\n\n// Using Option with pattern matching\nlet user = find_user(42)\nmatch user {\n    Some(u) => print(\"Found user: ${u.name}\"),\n    None => print(\"User not found\")\n}\n\n// Using Option with if-let\nif let Some(user) = find_user(123) {\n    print(\"User: ${user.name}\")\n} else {\n    print(\"No user with that ID\")\n}\n\n// Methods on Option\nlet name = find_user(42)\n    .map(|user| user.name)  // Transform the contained value\n    .unwrap_or(\"Unknown\")   // Default value if None\n```"}
{"input": "# Structs\n\nStructs in PyLang are used to create custom data types with named fields:\n\n```pylang\n// Defining a struct\nstruct Point {\n    x: float,\n    y: float\n}\n\n// Creating struct instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet point = Point { x: 3.5, y: -2.0 }\n\n// Accessing fields\nprint(\"Point coordinates: (${point.x}, ${point.y})\")\n\n// Struct update syntax\nlet another_point = Point { y: 10.0, ..point }  // x is copied from point\n\n// Tuple structs (unnamed fields)\nstruct Color(int, int, int)  // RGB color\n\nlet red = Color(255, 0, 0)\nprint(\"Red value: ${red.0}\")\n\n// Unit structs (no fields)\nstruct UnitStruct\n```"}
{"input": "# Struct Methods\n\nStructs in PyLang can have associated methods defined in implementation blocks:\n\n```pylang\nstruct Rectangle {\n    width: float,\n    height: float\n}\n\nimpl Rectangle {\n    // Constructor method (by convention)\n    func new(width: float, height: float) -> Rectangle {\n        return Rectangle { width, height }\n    }\n    \n    // Instance method (takes self parameter)\n    func area(&self) -> float {\n        return self.width * self.height\n    }\n    \n    // Mutable method (can modify the instance)\n    func scale(&mut self, factor: float) {\n        self.width *= factor\n        self.height *= factor\n    }\n    \n    // Static method (doesn't take self parameter)\n    func square(size: float) -> Rectangle {\n        return Rectangle { width: size, height: size }\n    }\n}\n\n// Using the methods\nlet mut rect = Rectangle::new(5.0, 3.0)\nprint(\"Area: ${rect.area()}\")\n\nrect.scale(2.0)\nprint(\"Scaled area: ${rect.area()}\")\n\nlet square = Rectangle::square(4.0)\n```"}
{"input": "# Enums\n\nEnums in PyLang define types with a fixed set of variants:\n\n```pylang\n// Basic enum\nenum Direction {\n    North,\n    East,\n    South,\n    West\n}\n\nlet heading = Direction::North\n\n// Pattern matching on enums\nmatch heading {\n    Direction::North => print(\"Heading north\"),\n    Direction::East => print(\"Heading east\"),\n    Direction::South => print(\"Heading south\"),\n    Direction::West => print(\"Heading west\")\n}\n\n// Enum with associated values\nenum Shape {\n    Circle(float),            // radius\n    Rectangle(float, float),   // width, height\n    Triangle(float, float, float)  // three sides\n}\n\nlet shape = Shape::Rectangle(5.0, 3.0)\n\n// Pattern matching with destructuring\nmatch shape {\n    Shape::Circle(radius) => print(\"Circle with radius ${radius}\"),\n    Shape::Rectangle(width, height) => print(\"${width}x${height} rectangle\"),\n    Shape::Triangle(a, b, c) => print(\"Triangle with sides ${a}, ${b}, ${c}\")\n}\n```"}
{"input": "# Enum Methods\n\nLike structs, enums in PyLang can have methods defined in implementation blocks:\n\n```pylang\nenum Shape {\n    Circle(float),            // radius\n    Rectangle(float, float),   // width, height\n    Triangle(float, float, float)  // three sides\n}\n\nimpl Shape {\n    // Calculate the area of any shape\n    func area(&self) -> float {\n        match self {\n            Shape::Circle(radius) => {\n                return 3.14159 * radius * radius\n            },\n            Shape::Rectangle(width, height) => {\n                return width * height\n            },\n            Shape::Triangle(a, b, c) => {\n                // Heron's formula\n                let s = (a + b + c) / 2.0\n                return (s * (s - a) * (s - b) * (s - c)).sqrt()\n            }\n        }\n    }\n    \n    // Check if the shape is regular\n    func is_regular(&self) -> bool {\n        match self {\n            Shape::Circle(_) => true,  // All circles are regular\n            Shape::Rectangle(w, h) => w == h,  // Only squares are regular rectangles\n            Shape::Triangle(a, b, c) => a == b && b == c  // Only equilateral triangles\n        }\n    }\n}\n\nlet circle = Shape::Circle(2.0)\nprint(\"Circle area: ${circle.area()}, regular: ${circle.is_regular()}\")\n```"}
{"input": "# Traits\n\nTraits in PyLang define shared behavior that types can implement:\n\n```pylang\n// Define a trait\ntrait Printable {\n    // Required method (must be implemented)\n    func to_string(&self) -> string"}
{"input": "# Traits (continued)\n\nTraits in PyLang define shared behavior that types can implement:\n\n```pylang\n// Define a trait\ntrait Printable {\n    // Required method (must be implemented)\n    func to_string(&self) -> string;\n    \n    // Default method (implementation provided)\n    func print(&self) {\n        println(self.to_string());\n    }\n}\n\n// Implement the trait for a type\nstruct Person {\n    name: string,\n    age: int\n}\n\nimpl Printable for Person {\n    func to_string(&self) -> string {\n        return \"Person {name: ${self.name}, age: ${self.age}}\";\n    }\n    // No need to implement print() as it uses the default implementation\n}\n\n// Using the trait\nlet alice = Person { name: \"Alice\", age: 30 };\nalice.print();  // Uses the trait method\n```\n\nTraits enable polymorphism and code reuse across different types."}
{"input": "# Trait Bounds\n\nTrait bounds in PyLang constrain generic types to implement specific traits:\n\n```pylang\n// Generic function with trait bound\nfunc print_item<T: Printable>(item: T) {\n    item.print();\n}\n\n// Multiple trait bounds\nfunc process<T: Serializable + Printable>(item: T) {\n    // Can use both Serializable and Printable methods on item\n    let json = item.to_json();\n    item.print();\n}\n\n// Where clause for complex bounds\nfunc transform<T, U>(input: T) -> U\nwhere\n    T: Convertible<U>,\n    U: Sized + Clone\n{\n    return input.convert();\n}\n\n// Trait objects for dynamic dispatch\nfunc print_items(items: List<Box<dyn Printable>>) {\n    for item in items {\n        item.print();\n    }\n}\n```\n\nTrait bounds ensure that generic code only works with types that provide the required functionality."}
{"input": "# Generics\n\nGenerics in PyLang allow you to write flexible, reusable code with type parameters:\n\n```pylang\n// Generic struct\nstruct Pair<T, U> {\n    first: T,\n    second: U\n}\n\n// Creating instances with different types\nlet int_pair = Pair { first: 1, second: 2 };\nlet mixed_pair = Pair { first: \"hello\", second: 5 };\n\n// Generic function\nfunc swap<T>(a: T, b: T) -> (T, T) {\n    return (b, a);\n}\n\nlet (b, a) = swap(\"hello\", \"world\");\n\n// Generic implementation\nimpl<T, U> Pair<T, U> {\n    func new(first: T, second: U) -> Pair<T, U> {\n        return Pair { first, second };\n    }\n    \n    func first_value(&self) -> &T {\n        return &self.first;\n    }\n}\n\n// Generic with trait bounds\nfunc largest<T: Comparable>(list: &[T]) -> &T {\n    let mut largest = &list;\n    for item in list.iter().skip(1) {\n        if item > largest {\n            largest = item;\n        }\n    }\n    return largest;\n}\n```"}
{"input": "# Lifetimes\n\nLifetimes in PyLang ensure that references remain valid for as long as they're used:\n\n```pylang\n// Function with explicit lifetime annotations\nfunc longest<'a>(x: &'a string, y: &'a string) -> &'a string {\n    if x.len() > y.len() {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Struct with references needs lifetime annotations\nstruct TextBlock<'a> {\n    content: &'a string,\n    title: &'a string\n}\n\nimpl<'a> TextBlock<'a> {\n    func new(content: &'a string, title: &'a string) -> TextBlock<'a> {\n        return TextBlock { content, title };\n    }\n}\n\n// Multiple lifetime parameters\nfunc combine<'a, 'b>(first: &'a string, second: &'b string) -> string {\n    return first.clone() + second;\n}\n\n// Static lifetime\nlet PROGRAM_NAME: &'static string = \"MyApp\";\n```\n\nLifetimes help the compiler ensure memory safety without garbage collection."}
{"input": "# Ownership\n\nOwnership is a key concept in PyLang that manages memory safety:\n\n```pylang\n// Ownership basics\nfunc ownership_example() {\n    let s1 = \"hello\".to_string();  // s1 owns the string\n    let s2 = s1;  // Ownership moves to s2\n    \n    // print(s1);  // Error: s1 has been moved and is no longer valid\n    print(s2);  // Works fine\n    \n    let x = 5;  // Primitive types are copied, not moved\n    let y = x;  // Both x and y are valid\n    print(\"x = ${x}, y = ${y}\");  // Works fine\n}\n\n// Functions take ownership\nfunc take_ownership(s: string) {\n    print(\"Took: ${s}\");\n    // s is dropped here when function ends\n}\n\nfunc give_ownership() -> string {\n    let s = \"hello\".to_string();\n    return s;  // Ownership is transferred to caller\n}\n\n// Example usage\nlet s = give_ownership();\ntake_ownership(s);\n// Using s here would cause an error\n```\n\nOwnership rules help prevent memory errors and enable automatic memory management."}
{"input": "# Borrowing\n\nBorrowing in PyLang allows temporary access to data without transferring ownership:\n\n```pylang\n// Immutable borrowing\nfunc calculate_length(s: &string) -> int {\n    return s.len();  // s is borrowed, not owned\n}\n\nlet text = \"hello world\".to_string();\nlet length = calculate_length(&text);  // Borrow text\nprint(text);  // Still valid as ownership wasn't transferred\n\n// Mutable borrowing\nfunc append_world(s: &mut string) {\n    s.append(\" world\");\n}\n\nlet mut greeting = \"hello\".to_string();\nappend_world(&mut greeting);  // Mutable borrow\nprint(greeting);  // \"hello world\"\n\n// Borrowing rules\nlet mut s = \"hello\".to_string();\nlet r1 = &s;  // Immutable borrow\nlet r2 = &s;  // Multiple immutable borrows are allowed\n\n// let r3 = &mut s;  // Error: can't borrow as mutable while borrowed as immutable\n\nprint(\"${r1}, ${r2}\");\n\n// After r1 and r2 are no longer used, mutable borrow is allowed\nlet r3 = &mut s;  // Now allowed\n// print(r1);  // Error: r1 can't be used after mutable borrow\n```"}
{"input": "# Memory Management: Scopes and Dropping\n\nPyLang automatically frees memory when variables go out of scope:\n\n```pylang\nfunc scope_example() {\n    {\n        let inner = \"I'm in an inner scope\".to_string();\n        print(inner);  // Works fine\n    }  // inner is dropped here\n    \n    // print(inner);  // Error: inner is no longer valid\n    \n    let outer = \"I'm in the outer scope\".to_string();\n    print(outer);  // Works fine\n}  // outer is dropped here\n\n// The Drop trait controls what happens when a value is dropped\nstruct Resource {\n    name: string\n}\n\nimpl Drop for Resource {\n    func drop(&mut self) {\n        print(\"Cleaning up resource: ${self.name}\");\n    }\n}\n\nfunc resource_example() {\n    let res1 = Resource { name: \"database connection\".to_string() };\n    {\n        let res2 = Resource { name: \"file handle\".to_string() };\n        print(\"Using resources...\");\n    }  // res2.drop() is called here\n    print(\"Still using res1...\");\n}  // res1.drop() is called here\n```"}
{"input": "# Smart Pointers: Box\n\nBox in PyLang is a smart pointer for heap allocation:\n\n```pylang\n// Basic Box usage\nlet b = Box::new(5);  // Allocates 5 on the heap\nprint(\"Value: ${*b}\");  // Dereference with *\n\n// Enabling recursive data structures\nstruct Node {\n    value: int,\n    next: Option<Box<Node>>  // Self-referential structure\n}\n\n// Creating a linked list\nlet list = Node {\n    value: 1,\n    next: Some(Box::new(Node {\n        value: 2,\n        next: Some(Box::new(Node {\n            value: 3,\n            next: None\n        }))\n    }))\n};\n\n// Accessing nested values\nlet second_value = list.next.as_ref().unwrap().value;  // 2\n\n// Box for trait objects\nlet printable: Box<dyn Printable> = Box::new(Person { name: \"Bob\".to_string(), age: 25 });\nprintable.print();  // Uses dynamic dispatch\n```\n\nBox is useful for recursive types, trait objects, and ensuring data is on the heap."}
{"input": "# Smart Pointers: Rc\n\nRc (Reference Counting) allows multiple ownership of the same data:\n\n```pylang\nimport std::rc::Rc;\n\n// Creating a shared value\nlet data = Rc::new(\"Hello, world!\".to_string());\n\n// Creating multiple owners\nlet owner1 = data.clone();  // Increments the reference count\nlet owner2 = data.clone();  // Increments the reference count\n\nprint(\"Reference count: ${Rc::strong_count(&data)}\");  // 3\n\n// Shared ownership of complex structures\nstruct Node {\n    value: int,\n    children: List<Rc<Node>>\n}\n\n// Creating a tree structure\nlet leaf1 = Rc::new(Node { value: 2, children: List::new() });\nlet leaf2 = Rc::new(Node { value: 3, children: List::new() });\n\nlet root = Rc::new(Node {\n    value: 1,\n    children: List::from([leaf1.clone(), leaf2.clone()])\n});\n\n// Data is dropped when the last owner is dropped\ndrop(owner1);  // Reference count decreases to 2\nprint(\"Reference count: ${Rc::strong_count(&data)}\");  // 2\n```\n\nRc is useful for shared data structures but doesn't allow mutation by default."}
{"input": "# Smart Pointers: Arc\n\nArc (Atomic Reference Counting) enables thread-safe shared ownership:\n\n```pylang\nimport std::sync::Arc;\nimport std::thread;\n\n// Creating thread-safe shared data\nlet data = Arc::new(\"Hello from multiple threads!\".to_string());\n\nlet mut handles = List::new();\n\n// Spawn multiple threads that access the data\nfor id in 1..=3 {\n    let thread_data = data.clone();  // Increment reference count\n    \n    let handle = thread::spawn(move || {\n        print(\"Thread ${id}: ${thread_data}\");\n    });\n    \n    handles.push(handle);\n}\n\n// Wait for all threads to finish\nfor handle in handles {\n    handle.join().unwrap();\n}\n\nprint(\"Done!\");\n\n// Arc combined with Mutex for mutable shared state\nimport std::sync::Mutex;\n\nlet counter = Arc::new(Mutex::new(0));\nlet mut thread_handles = List::new();\n\nfor _ in 0..10 {\n    let counter_ref = counter.clone();\n    let handle = thread::spawn(move || {\n        let mut num = counter_ref.lock().unwrap();\n        *num += 1;\n    });\n    thread_handles.push(handle);\n}\n```"}
{"input": "# Concurrency: Threads\n\nPyLang provides native thread support for concurrent execution:\n\n```pylang\nimport std::thread;\nimport std::time;\n\n// Spawning a basic thread\nlet handle = thread::spawn(|| {\n    print(\"Hello from a thread!\");\n});\n\n// Wait for the thread to finish\nhandle.join().unwrap();\n\n// Threads with parameters using move closures\nlet data = vec![1, 2, 3];\n\nlet handle = thread::spawn(move || {\n    print(\"Thread has data: ${data}\");\n});\n\n// print(data);  // Error: data has been moved to the thread\n\nhandle.join().unwrap();\n\n// Multiple threads\nlet mut handles = List::new();\n\nfor i in 0..5 {\n    let handle = thread::spawn(move || {\n        print(\"Thread ${i} is running\");\n        thread::sleep(time::Duration::from_millis(100));\n        print(\"Thread ${i} is done\");\n    });\n    handles.push(handle);\n}\n\n// Wait for all threads\nfor handle in handles {\n    handle.join().unwrap();\n}\n```"}
{"input": "# Concurrency: Mutex and RwLock\n\nPyLang provides synchronization primitives for safe concurrent access to shared data:\n\n```pylang\nimport std::sync::{Mutex, RwLock, Arc};\nimport std::thread;\n\n// Mutex for exclusive access\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles = List::new();\n\nfor _ in 0..10 {\n    let counter_ref = counter.clone();\n    let handle = thread::spawn(move || {\n        // Lock the mutex to get exclusive access\n        let mut value = counter_ref.lock().unwrap();\n        *value += 1;\n        // Mutex is automatically unlocked when value goes out of scope\n    });\n    handles.push(handle);\n}\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n\nprint(\"Final count: ${*counter.lock().unwrap()}\");  // 10\n\n// RwLock for reader-writer access patterns\nlet data = Arc::new(RwLock::new(vec![1, 2, 3]));\n\n// Multiple readers can access simultaneously\nlet reader1 = data.clone();\nlet reader2 = data.clone();\n\nlet read_handle1 = thread::spawn(move || {\n    let values = reader1.read().unwrap();\n    print(\"Reader 1: ${values}\");\n});\n\nlet read_handle2 = thread::spawn(move || {\n    let values = reader2.read().unwrap();\n    print(\"Reader 2: ${values}\");\n});\n\n// Writers get exclusive access\nlet writer = data.clone();\nlet write_handle = thread::spawn(move || {\n    let mut values = writer.write().unwrap();\n    values.push(4);\n    print(\"Writer: ${values}\");\n});\n```"}
{"input": "# Concurrency: Channels\n\nChannels in PyLang allow communication between threads:\n\n```pylang\nimport std::sync::mpsc;\nimport std::thread;\nimport std::time::Duration;\n\n// Creating a channel\nlet (tx, rx) = mpsc::channel();\n\n// Sender thread\nlet sender_handle = thread::spawn(move || {\n    let messages = [\"Hello\", \"from\", \"the\", \"other\", \"thread\"];\n    \n    for msg in messages {\n        tx.send(msg).unwrap();\n        thread::sleep(Duration::from_millis(100));\n    }\n});\n\n// Receiver thread\nlet receiver_handle = thread::spawn(move || {\n    // Receiving individual messages\n    while let Ok(message) = rx.recv() {\n        print(\"Received: ${message}\");\n    }\n});\n\nsender_handle.join().unwrap();\nreceiver_handle.join().unwrap();\n\n// Multiple producers\nlet (tx, rx) = mpsc::channel();\n\nfor i in 0..5 {\n    let tx_clone = tx.clone();\n    thread::spawn(move || {\n        tx_clone.send(format(\"Message from thread ${i}\")).unwrap();\n    });\n}\n\n// Drop the original sender to close the channel after all clones are done\ndrop(tx);\n\n// Collect all messages\nwhile let Ok(message) = rx.recv() {\n    print(message);\n}\n```"}
{"input": "# Async/Await\n\nPyLang supports asynchronous programming with async/await syntax:\n\n```pylang\nimport std::async;\n\n// Defining an async function\nasync func fetch_data(url: string) -> Result<string, Error> {\n    print(\"Fetching ${url}...\");\n    // Simulate network request\n    await async::sleep(Duration::from_millis(100));\n    return Ok(format(\"Data from ${url}\"));\n}\n\n// Async functions can be composed\nasync func process_data(url: string) -> Result<string, Error> {\n    let data = await fetch_data(url)?;\n    print(\"Processing ${data}...\");\n    await async::sleep(Duration::from_millis(50));\n    return Ok(format(\"Processed ${data}\"));\n}\n\n// Running async code\nasync func main_async() {\n    let urls = [\"http://example.com/1\", \"http://example.com/2\"];\n    \n    // Sequential execution\n    for url in urls {\n        match await process_data(url) {\n            Ok(result) => print(result),\n            Err(e) => print(\"Error: ${e}\")\n        }\n    }\n    \n    // Parallel execution\n    let tasks: Vec<_> = urls\n        .map(|url| async::spawn(process_data(url)))\n        .collect();\n    \n    for task in tasks {\n        match await task {\n            Ok(Ok(result)) => print(result),\n            Ok(Err(e)) => print(\"Request error: ${e}\"),\n            Err(e) => print(\"Task error: ${e}\")\n        }\n    }\n}\n\n// Run the async function\nasync::Runtime::new().unwrap().block_on(main_async());\n```"}
{"input": "# Future and Stream\n\nPyLang's async ecosystem includes Future and Stream abstractions:\n\n```pylang\nimport std::future::Future;\nimport std::stream::Stream;\n\n// Working with Futures\nasync func future_example() {\n    // Creating a future\n    let future = async {\n        await async::sleep(Duration::from_millis(100));\n        return 42;\n    };\n    \n    // Awaiting a future\n    let result = await future;\n    print(\"Future result: ${result}\");\n    \n    // Combining futures\n    let f1 = async { return \"hello\"; };\n    let f2 = async { return \"world\"; };\n    \n    // Run futures concurrently and collect results\n    let (r1, r2) = async::join(f1, f2).await;\n    print(\"${r1} ${r2}\");\n}\n\n// Working with Streams\nasync func stream_example() {\n    // Creating a stream\n    let mut stream = async::stream::iter(1..=5);\n    \n    // Processing stream items\n    while let Some(item) = await stream.next() {\n        print(\"Stream item: ${item}\");\n    }\n    \n    // Stream transformations\n    let doubled = async::stream::iter(1..=5)\n        .map(|x| x * 2)\n        .filter(|x| x > 5);\n    \n    // Collecting stream results\n    let results: Vec<_> = await doubled.collect();\n    print(\"Collected: ${results}\");\n}\n```"}
{"input": "# Pattern Matching: Destructuring\n\nPyLang's pattern matching supports complex destructuring:\n\n```pylang\n// Destructuring tuples\nlet point = (10, 20);\nlet (x, y) = point;\nprint(\"x: ${x}, y: ${y}\");\n\n// Destructuring structs\nstruct Person {\n    name: string,\n    age: int\n}\n\nlet person = Person { name: \"Alice\".to_string(), age: 30 };\nlet Person { name, age } = person;\nprint(\"${name} is ${age} years old\");\n\n// Destructuring with match\nlet value = (\"hello\", 42);\n\nmatch value {\n    (\"hello\", n) => print(\"Hello with ${n}\"),\n    (\"bye\", n) => print(\"Goodbye with ${n}\"),\n    _ => print(\"Something else\")\n}\n\n// Nested destructuring\nlet nested = ((1, 2), (3, 4));\n\nmatch nested {\n    ((a, b), (c, d)) => print(\"Values: ${a}, ${b}, ${c}, ${d}\")\n}\n\n// Destructuring with guards\nlet pair = (3, 4);\n\nmatch pair {\n    (x, y) if x == y => print(\"Equal coordinates\"),\n    (x, y) if x > y => print(\"x is greater\"),\n    (x, y) => print(\"y is greater\")\n}\n```"}
{"input": "# Pattern Matching: Advanced Features\n\nPyLang offers advanced pattern matching capabilities:\n\n```pylang\n// Range patterns\nlet x = 5;\n\nmatch x {\n    1..=5 => print(\"1 to 5\"),\n    6..=10 => print(\"6 to 10\"),\n    _ => print(\"something else\")\n}\n\n// Multiple patterns\nmatch x {\n    1 | 3 | 5 | 7 | 9 => print(\"Odd number from 1-9\"),\n    2 | 4 | 6 | 8 => print(\"Even number from 2-8\"),\n    _ => print(\"Out of range\")\n}\n\n// Binding with @ pattern\nmatch x {\n    n @ 1..=5 => print(\"${n} is between 1 and 5\"),\n    n @ 6..=10 => print(\"${n} is between 6 and 10\"),\n    n => print(\"${n} is outside ranges\")\n}\n\n// Pattern matching with Option\nlet maybe_value: Option<int> = Some(42);\n\nmatch maybe_value {\n    Some(n) if n > 100 => print(\"Large number\"),\n    Some(n) => print(\"Got ${n}\"),\n    None => print(\"No value\")\n}\n\n// Pattern matching with Result\nlet result: Result<int, string> = Ok(42);\n\nmatch result {\n    Ok(n) => print(\"Success: ${n}\"),\n    Err(e) => print(\"Error: ${e}\")\n}\n```"}
{"input": "# Modules and Imports\n\nPyLang organizes code into modules and packages:\n\n```pylang\n// File: math_utils.pyl\nmodule math_utils;\n\npublic func add(a: int, b: int) -> int {\n    return a + b;\n}\n\npublic func subtract(a: int, b: int) -> int {\n    return a - b;\n}\n\n// Private function (not accessible outside this module)\nfunc helper() -> string {\n    return \"I'm a helper function\";\n}\n\n// File: main.pyl\nimport math_utils;  // Import the entire module\n\nfunc main() {\n    let sum = math_utils::add(5, 3);\n    print(\"Sum: ${sum}\");\n}\n\n// Selective imports\nimport math_utils::{add, subtract};\n\nfunc calculate() {\n    let sum = add(10, 5);  // Directly use add without module prefix\n    let diff = subtract(10, 5);\n}\n\n// Renaming imports\nimport math_utils::add as addition;\n\nfunc renamed() {\n    let result = addition(7, 8);  // Using the renamed import\n}\n```"}
{"input": "# Packages and Project Structure\n\nPyLang organizes code into packages with a defined structure:\n\n```\nmy_project/\n├── Pylfile.toml      # Project configuration file\n├── src/\n│   ├── main.pyl      # Entry point\n│   ├── lib.pyl       # Library exports\n│   ├── utils/        # Submodule directory\n│   │   ├── mod.pyl   # Submodule definition\n│   │   ├── io.pyl    # IO utilities\n│   │   └── math.pyl  # Math utilities\n│   └── models/       # Another submodule\n│       ├── mod.pyl   # Submodule definition\n│       └── user.pyl  # User model\n└── tests/            # Test directory\n    └── test_utils.pyl\n```\n\n```pylang\n// File: src/lib.pyl\nmodule my_project;\n\n// Re-export submodules\npublic import utils;\npublic import models;\n\n// Public API\npublic func version() -> string {\n    return \"1.0.0\";\n}\n\n// File: src/utils/mod.pyl\nmodule my_project::utils;\n\n// Re-export specific items from submodules\npublic import io::{read_file, write_file};\npublic import math::calculate;\n\n// File: src/main.pyl\nimport my_project::{utils, models, version};\n\nfunc main() {\n    print(\"Version: ${version()}\");\n    let data = utils::read_file(\"config.json\");\n    let user = models::User::from_json(data);\n}\n```"}
{"input": "# Error Handling: Custom Errors\n\nPyLang allows defining custom error types:\n\n```pylang\n// Define a custom error type\nenum AppError {\n    IoError(std::io::Error),\n    ParseError { line: int, message: string },\n    ValidationError(string),\n    NotFound\n}\n\n// Implement standard error traits\nimpl std::error::Error for AppError {}\n\nimpl Display for AppError {\n    func fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            AppError::IoError(e) => write!(f, \"IO error: ${e}\"),\n            AppError::ParseError { line, message } => write!(f, \"Parse error at line ${line}: ${message}\"),\n            AppError::ValidationError(msg) => write!(f, \"Validation failed: ${msg}\"),\n            AppError::NotFound => write!(f, \"Resource not found\")\n        }\n    }\n}\n\n// Convert from standard error types\nimpl From<std::io::Error> for AppError {\n    func from(error: std::io::Error) -> Self {\n        return AppError::IoError(error);\n    }\n}\n\n// Function that returns the custom error\nfunc process_file(path: string) -> Result<string, AppError> {\n    // The ? operator works with our custom error type\n    let content = std::fs::read_to_string(path)?;  // IoError is automatically converted\n    \n    if content.is_empty() {\n        return Err(AppError::ValidationError(\"File is empty\".to_string()));\n    }\n    \n    // More processing...\n    return Ok(content);\n}\n```"}
{"input": "# Unit Testing\n\nPyLang has built-in support for unit testing:\n\n```pylang\nmodule math;\n\npublic func add(a: int, b: int) -> int {\n    return a + b;\n}\n\npublic func subtract(a: int, b: int) -> int {\n    return a - b;\n}\n\n#[test]  // Test module with test functions\nmodule tests {\n    import super::*;  // Import from parent module\n    \n    #[test]  // Test function annotation\n    func test_add() {\n        assert_eq(add(2, 3), 5);\n        assert_eq(add(0, 0), 0);\n        assert_eq(add(-1, 1), 0);\n    }\n    \n    #[test]\n    func test_subtract() {\n        assert_eq(subtract(5, 2), 3);\n        assert_eq(subtract(0, 0), 0);\n        assert_eq(subtract(1, 1), 0);\n    }\n    \n    #[test]\n    #[should_panic]  // Test expected to panic\n    func test_panic() {\n        let x = [1, 2, 3];\n        let _ = x;  // This will panic\n    }\n    \n    #[test]\n    func test_with_description() {\n        let result = add(2, 2);\n        assert_eq(result, 4, \"2 + 2 should equal 4\");\n    }\n}\n\n// Run tests with: pylc test\n```"}
{"input": "# Integration Testing\n\nPyLang supports integration tests across modules:\n\n```pylang\n// File: tests/integration_tests.pyl\nmodule tests;\n\nimport my_project::utils;\nimport my_project::models;\n\n#[test]\nfunc test_user_creation() {\n    // Test that involves multiple modules\n    let data = utils::read_file(\"test_data/user.json\");\n    let user = models::User::from_json(data);\n    \n    assert_eq(user.name"}
{"input": "# PyLang Introduction\n\nPyLang is a modern systems programming language designed to combine Python's readability with the performance and safety of languages like Rust and C++. It features static typing with type inference, memory safety without garbage collection, and first-class concurrency support.\n\nPyLang was created in 2023 to address common pain points in existing languages while providing a gentle learning curve for developers from various backgrounds. Its syntax is clean and expressive, while its compiler provides helpful error messages to guide developers."}
{"input": "# Hello World in PyLang\n\nThe traditional first program in PyLang looks like this:\n\n```pylang\nfunc main() {\n    print(\"Hello, World!\")\n}\n```\n\nTo compile and run this program:\n\n```bash\n# Save as hello.pyl\npylc hello.pyl\n./hello\n```\n\nThe `func` keyword defines a function, and `main()` is the entry point of the program. The `print` function outputs text to the console."}
{"input": "# Comments in PyLang\n\nPyLang supports three types of comments:\n\n```pylang\n// Single-line comments run to the end of the line\n\n/* Multi-line comments can span\n   multiple lines and are useful for\n   longer explanations */\n\n/// Documentation comments are used to generate documentation\n/// They support Markdown formatting\nfunc documented_function() {\n    // Implementation\n}\n```\n\nDocumentation comments are particularly useful as they're processed by PyLang's documentation generator tool `pyldoc`."}
{"input": "# Variables and Constants\n\nIn PyLang, variables are declared using the `var` keyword for mutable values and `let` for immutable values:\n\n```pylang\n// Mutable variable\nvar counter = 1\ncounter += 1  // Valid: counter can be modified\n\n// Immutable variable (constant)\nlet pi = 3.14159\npi = 3.0  // Error: cannot assign twice to immutable variable\n```\n\nType annotations are optional but can be added for clarity:\n\n```pylang\nvar name: string = \"Alice\"\nlet max_value: int = 100\n```"}
{"input": "# Basic Types\n\nPyLang includes the following primitive types:\n\n```pylang\n// Integer types\nlet i: int = 42       // Platform-dependent size (usually 64-bit)\nlet i8: i8 = 127      // 8-bit signed integer\nlet i16: i16 = 32767  // 16-bit signed integer\nlet i32: i32 = 2147483647  // 32-bit signed integer\nlet i64: i64 = 9223372036854775807  // 64-bit signed integer\n\n// Unsigned integer types\nlet u: uint = 42      // Platform-dependent size\nlet u8: u8 = 255     // 8-bit unsigned integer\nlet u16: u16 = 65535 // 16-bit unsigned integer\nlet u32: u32 = 4294967295 // 32-bit unsigned integer\nlet u64: u64 = 18446744073709551615 // 64-bit unsigned integer\n\n// Floating point types\nlet f32: f32 = 3.14  // 32-bit floating point\nlet f64: f64 = 3.14159265359  // 64-bit floating point\n\n// Boolean type\nlet b: bool = true\n\n// Character type\nlet c: char = 'A'\n\n// String type\nlet s: string = \"Hello, PyLang!\"\n```"}
{"input": "# Type Inference\n\nPyLang has powerful type inference, meaning you often don't need to specify types explicitly:\n\n```pylang\nlet name = \"Alice\"  // Inferred as string\nlet age = 30       // Inferred as int\nlet height = 5.9   // Inferred as f64\nlet is_student = false  // Inferred as bool\n\nfunc add(a, b) {\n    return a + b\n}\n\nlet sum = add(5, 3)  // Inferred return type is int\nlet message = add(\"Hello, \", \"World\")  // Inferred return type is string\n```\n\nThe compiler analyzes the code to determine appropriate types. However, adding explicit type annotations can improve code readability and catch errors earlier."}
{"input": "# Operators in PyLang\n\nPyLang provides a variety of operators for different operations:\n\n```pylang\n// Arithmetic operators\nlet sum = 5 + 3       // Addition\nlet difference = 10 - 4  // Subtraction\nlet product = 6 * 3     // Multiplication\nlet quotient = 15 / 5   // Division\nlet remainder = 10 % 3  // Modulo\nlet power = 2 ** 3      // Exponentiation (2³ = 8)\n\n// Comparison operators\nlet equal = (5 == 5)         // Equal to\nlet not_equal = (5 != 3)     // Not equal to\nlet greater = (10 > 5)       // Greater than\nlet less = (5 < 10)          // Less than\nlet greater_equal = (10 >= 10)  // Greater than or equal to\nlet less_equal = (5 <= 10)      // Less than or equal to\n\n// Logical operators\nlet and_result = true && false  // Logical AND\nlet or_result = true || false   // Logical OR\nlet not_result = !true          // Logical NOT\n```"}
{"input": "# Compound Assignment Operators\n\nPyLang supports compound assignment operators that combine an operation with assignment:\n\n```pylang\nvar x = 10\n\nx += 5      // Equivalent to: x = x + 5\nx -= 3      // Equivalent to: x = x - 3\nx *= 2      // Equivalent to: x = x * 2\nx /= 4      // Equivalent to: x = x / 4\nx %= 3      // Equivalent to: x = x % 3\nx **= 2     // Equivalent to: x = x ** 2\n\n// Bitwise compound assignments\nx &= 0b1100  // Equivalent to: x = x & 0b1100\nx |= 0b0011  // Equivalent to: x = x | 0b0011\nx ^= 0b1010  // Equivalent to: x = x ^ 0b1010\nx <<= 2     // Equivalent to: x = x << 2\nx >>= 1     // Equivalent to: x = x >> 1\n```\n\nThese operators make code more concise and readable when modifying variables."}
{"input": "# String Basics\n\nStrings in PyLang are UTF-8 encoded and support a wide range of operations:\n\n```pylang\n// String creation\nlet greeting = \"Hello\"\nlet name = \"World\"\n\n// String concatenation\nlet message = greeting + \", \" + name + \"!\"\n\n// String interpolation\nlet interpolated = \"${greeting}, ${name}!\"\n\n// Multi-line strings\nlet multi = \"\"\"\n    This is a multi-line string.\n    It preserves whitespace and newlines.\n    No need for escape sequences for line breaks.\n\"\"\"\n\n// Common string methods\nlet uppercase = greeting.to_upper()  // \"HELLO\"\nlet lowercase = greeting.to_lower()  // \"hello\"\nlet length = greeting.length()       // 5\nlet contains = greeting.contains(\"lo\")  // true\n```"}
{"input": "# String Methods\n\nPyLang strings have many built-in methods for manipulation and analysis:\n\n```pylang\nlet text = \"Hello, PyLang World!\"\n\n// Searching and extracting\nlet contains = text.contains(\"PyLang\")  // true\nlet starts_with = text.starts_with(\"Hello\")  // true\nlet ends_with = text.ends_with(\"!\")  // true\nlet index = text.find(\"PyLang\")  // 7\nlet substring = text.substring(7, 13)  // \"PyLang\"\n\n// Modifying\nlet replaced = text.replace(\"PyLang\", \"Amazing\")  // \"Hello, Amazing World!\"\nlet trimmed = \"  spaces  \".trim()  // \"spaces\"\nlet split = text.split(\", \")  // [\"Hello\", \"PyLang World!\"]\nlet joined = [\"Hello\", \"PyLang\", \"World\"].join(\" \")  // \"Hello PyLang World\"\n\n// Case conversion\nlet upper = text.to_upper()  // \"HELLO, PYLANG WORLD!\"\nlet lower = text.to_lower()  // \"hello, pylang world!\"\nlet title = text.to_title_case()  // \"Hello, Pylang World!\"\n```"}
{"input": "# Tuples\n\nTuples in PyLang are fixed-size collections of values that can have different types:\n\n```pylang\n// Creating tuples\nlet person = (\"Alice\", 30, true)\n\n// Accessing elements (zero-indexed)\nlet name = person.0  // \"Alice\"\nlet age = person.1   // 30\nlet is_active = person.2  // true\n\n// Tuple type annotation\nlet coordinates: (f64, f64) = (37.7749, -122.4194)\n\n// Destructuring tuples\nlet (lat, long) = coordinates\nprint(\"Latitude: ${lat}, Longitude: ${long}\")\n\n// Single-element tuples require a trailing comma\nlet single_item = (42,)\n```\n\nTuples are immutable, meaning their values cannot be changed after creation."}
{"input": "# Arrays\n\nArrays in PyLang are fixed-size collections of elements of the same type:\n\n```pylang\n// Creating arrays\nlet numbers = [1, 2, 3, 4, 5]\nlet zeros = [0; 10]  // Creates [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n// With type annotation\nlet fibonacci: [int; 5] = [1, 1, 2, 3, 5]\n\n// Accessing elements (zero-indexed)\nlet first = numbers  // 1\nlet last = numbers   // 5\n\n// Getting array properties\nlet length = numbers.len()  // 5\n\n// Arrays are fixed-size but elements can be modified if the array is mutable\nvar mutable_array = [1, 2, 3]\nmutable_array = 42  // Now [1, 42, 3]\n```\n\nArrays have a fixed size known at compile time and are stored on the stack."}
{"input": "# Lists\n\nLists in PyLang are dynamic-size collections similar to arrays but can grow or shrink:\n\n```pylang\n// Creating lists\nlet mut fruits = List::new()  // Empty list\nfruits.push(\"Apple\")\nfruits.push(\"Banana\")\nfruits.push(\"Cherry\")\n\n// Creating with initial values\nlet mut numbers = List::from([1, 2, 3, 4, 5])\n\n// With type annotation\nlet mut names: List<string> = List::new()\n\n// Common operations\nnumbers.push(6)       // Add to end\nlet last = numbers.pop()  // Remove from end\nlet first = numbers.remove(0)  // Remove at index\nnumbers.insert(0, 42)  // Insert at index\n\n// Properties and methods\nlet size = fruits.len()  // 3\nlet is_empty = fruits.is_empty()  // false\nlet contains = fruits.contains(\"Banana\")  // true\n```\n\nLists are allocated on the heap and can change size during runtime."}
{"input": "# Dictionaries\n\nDictionaries (or maps) in PyLang store key-value pairs with fast lookups:\n\n```pylang\n// Creating dictionaries\nlet mut user = Dict::new()\nuser[\"name\"] = \"Alice\"\nuser[\"age\"] = 30\nuser[\"is_admin\"] = true\n\n// Creating with initial values\nlet mut scores = Dict::from([\n    (\"Alice\", 95),\n    (\"Bob\", 87),\n    (\"Charlie\", 92)\n])\n\n// With type annotation\nlet mut config: Dict<string, string> = Dict::new()\n\n// Common operations\nlet alice_score = scores[\"Alice\"]  // 95\nscores[\"Dave\"] = 88  // Add new entry\nscores.remove(\"Bob\")  // Remove entry\n\n// Safe access with optionals\nif let Some(score) = scores.get(\"Eve\") {\n    print(\"Eve's score: ${score}\")\n} else {\n    print(\"Eve not found\")\n}\n\n// Properties and methods\nlet size = scores.len()  // 2\nlet keys = scores.keys()  // [\"Alice\", \"Charlie\"]\nlet values = scores.values()  // [95, 92]\n```"}
{"input": "# Sets\n\nSets in PyLang are collections of unique values with no duplicates:\n\n```pylang\n// Creating sets\nlet mut unique_numbers = Set::new()\nunique_numbers.insert(1)\nunique_numbers.insert(2)\nunique_numbers.insert(3)\nunique_numbers.insert(2)  // Duplicate, not added\n\n// Creating with initial values\nlet mut fruits = Set::from([\"Apple\", \"Banana\", \"Cherry\"])\n\n// With type annotation\nlet mut ids: Set<int> = Set::new()\n\n// Common operations\nfruits.insert(\"Date\")  // Add item\nfruits.remove(\"Banana\")  // Remove item\nlet has_apple = fruits.contains(\"Apple\")  // true\n\n// Set operations\nlet set1 = Set::from([1, 2, 3, 4])\nlet set2 = Set::from([3, 4, 5, 6])\n\nlet union = set1.union(&set2)  // {1, 2, 3, 4, 5, 6}\nlet intersection = set1.intersection(&set2)  // {3, 4}\nlet difference = set1.difference(&set2)  // {1, 2}\n```"}
{"input": "# Control Flow: If-Else\n\nConditional execution in PyLang uses if-else statements:\n\n```pylang\nlet temperature = 28\n\n// Basic if-else\nif temperature > 30 {\n    print(\"It's hot!\")\n} else if temperature > 20 {\n    print(\"It's warm.\")\n} else {\n    print(\"It's cool.\")\n}\n\n// If expressions (returning values)\nlet description = if temperature > 30 {\n    \"hot\"\n} else if temperature > 20 {\n    \"warm\"\n} else {\n    \"cool\"\n}\n\nprint(\"It's ${description} today.\")\n\n// Conditional assignment\nlet message = if is_morning { \"Good morning\" } else { \"Hello\" }\n```\n\nUnlike some languages, PyLang requires braces around the body of each branch."}
{"input": "# Control Flow: Match Expressions\n\nPyLang's match expressions provide powerful pattern matching:\n\n```pylang\nlet status_code = 404\n\n// Basic matching on values\nmatch status_code {\n    200 => print(\"OK\"),\n    404 => print(\"Not Found\"),\n    500 => print(\"Server Error\"),\n    _ => print(\"Unknown status: ${status_code}\")  // Default case\n}\n\n// Match expressions can return values\nlet message = match status_code {\n    200 => \"Success!\",\n    400..499 => \"Client error\",  // Range matching\n    500..599 => \"Server error\",\n    _ => \"Unknown status code\"\n}\n\n// Pattern matching with destructuring\nlet point = (10, 5)\nmatch point {\n    (0, 0) => print(\"At origin\"),\n    (0, y) => print(\"On y-axis at ${y}\"),\n    (x, 0) => print(\"On x-axis at ${x}\"),\n    (x, y) => print(\"At position (${x}, ${y})\")\n}\n```"}
{"input": "# Control Flow: For Loops\n\nFor loops in PyLang are used to iterate over collections or ranges:\n\n```pylang\n// Iterating over a range\nfor i in 1..5 {\n    print(\"Iteration ${i}\")\n}\n\n// Inclusive range (includes the upper bound)\nfor i in 1..=5 {\n    print(\"Number ${i}\")\n}\n\n// Iterating over collections\nlet colors = [\"red\", \"green\", \"blue\"]\nfor color in colors {\n    print(\"Color: ${color}\")\n}\n\n// With index\nfor (index, color) in colors.enumerate() {\n    print(\"${index}: ${color}\")\n}\n\n// Iterating over dictionaries\nlet scores = Dict::from([(\"Alice\", 95), (\"Bob\", 87)])\nfor (name, score) in scores {\n    print(\"${name}: ${score}\")\n}\n```\n\nThe for loop automatically handles iteration over various collection types."}
{"input": "# Control Flow: While Loops\n\nWhile loops in PyLang execute a block of code as long as a condition is true:\n\n```pylang\n// Basic while loop\nlet mut counter = 0\nwhile counter < 5 {\n    print(\"Counter: ${counter}\")\n    counter += 1\n}\n\n// Break and continue\nlet mut i = 0\nwhile i < 10 {\n    i += 1\n    if i % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    if i > 7 {\n        break  // Exit the loop early\n    }\n    print(\"Odd number: ${i}\")\n}\n\n// While-let loop (pattern matching in condition)\nlet mut optional = Some(0)\nwhile let Some(value) = optional {\n    if value >= 5 {\n        optional = None\n    } else {\n        print(\"Got value: ${value}\")\n        optional = Some(value + 1)\n    }\n}\n```"}
{"input": "# Control Flow: Loop and Break/Continue\n\nPyLang provides the `loop` keyword for infinite loops, along with `break` and `continue` for controlling loop flow:\n\n```pylang\n// Infinite loop with break\nlet mut counter = 0\nloop {\n    counter += 1\n    print(\"Iteration ${counter}\")\n    \n    if counter >= 5 {\n        break  // Exit the loop\n    }\n}\n\n// Loop with continue\nlet mut i = 0\nloop {\n    i += 1\n    \n    if i % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    \n    print(\"Odd number: ${i}\")\n    \n    if i >= 9 {\n        break\n    }\n}\n\n// Loop with labeled break/continue\n'outer: loop {\n    let mut j = 0\n    loop {\n        j += 1\n        if j > 5 {\n            break  // Breaks the inner loop\n        }\n        if j * j > 20 {\n            break 'outer  // Breaks the outer loop\n        }\n    }\n}\n```"}
{"input": "# Functions\n\nFunctions in PyLang are defined using the `func` keyword:\n\n```pylang\n// Basic function\nfunc greet(name: string) {\n    print(\"Hello, ${name}!\")\n}\n\n// Function with return type\nfunc add(a: int, b: int) -> int {\n    return a + b\n}\n\n// Function with multiple return values using tuples\nfunc divide(a: int, b: int) -> (int, int) {\n    let quotient = a / b\n    let remainder = a % b\n    return (quotient, remainder)\n}\n\n// Using the function\nlet sum = add(5, 3)  // 8\nlet (quot, rem) = divide(10, 3)  // (3, 1)\n\n// Functions with default parameters\nfunc create_profile(name: string, age: int = 30, active: bool = true) -> Dict<string, Any> {\n    return Dict::from([\n        (\"name\", name),\n        (\"age\", age),\n        (\"active\", active)\n    ])\n}\n```"}
{"input": "# Function Expressions and Closures\n\nPyLang supports function expressions and closures for functional programming:\n\n```pylang\n// Function assigned to a variable\nlet multiply = func(a: int, b: int) -> int {\n    return a * b\n}\n\nlet result = multiply(5, 3)  // 15\n\n// Anonymous functions (lambda expressions)\nlet numbers = [1, 2, 3, 4, 5]\nlet squares = numbers.map(func(x) -> int { return x * x })\n\n// Shorthand closure syntax\nlet cubes = numbers.map(|x| x * x * x)\n\n// Closures capturing environment variables\nfunc create_counter(start: int) -> func() -> int {\n    let mut count = start\n    \n    return func() -> int {\n        count += 1\n        return count\n    }\n}\n\nlet counter = create_counter(0)\nprint(counter())  // 1\nprint(counter())  // 2\n```"}
{"input": "# Error Handling: Result Type\n\nPyLang uses the Result type for operations that might fail:\n\n```pylang\n// Result type definition\n// enum Result<T, E> {\n//     Ok(T),\n//     Err(E)\n// }\n\n// Function that returns a Result\nfunc divide(a: int, b: int) -> Result<int, string> {\n    if b == 0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Using the Result with pattern matching\nlet result = divide(10, 2)\nmatch result {\n    Ok(value) => print(\"Result: ${value}\"),\n    Err(message) => print(\"Error: ${message}\")\n}\n\n// Using the Result with if-let\nif let Ok(value) = divide(10, 5) {\n    print(\"Division result: ${value}\")\n}\n\n// Methods on Result\nlet safe_divide = divide(10, 0)\n    .map(|x| x * 2)  // Only applied if Ok\n    .unwrap_or(0)    // Default value if Err\n```"}
{"input": "# Error Handling: Try Operator\n\nPyLang provides the `try` operator for convenient error propagation:\n\n```pylang\n// Without try operator\nfunc process_data(data: string) -> Result<int, string> {\n    let parsed = parse_number(data);\n    match parsed {\n        Ok(number) => {\n            let result = transform_number(number);\n            match result {\n                Ok(transformed) => return Ok(transformed),\n                Err(e) => return Err(e)\n            }\n        },\n        Err(e) => return Err(e)\n    }\n}\n\n// With try operator\nfunc process_data_concise(data: string) -> Result<int, string> {\n    let number = try parse_number(data);\n    let transformed = try transform_number(number);\n    return Ok(transformed);\n}\n\n// The try operator automatically unwraps Ok values or returns Err values\n// This makes code much more readable when chaining multiple fallible operations\nfunc read_config() -> Result<Config, string> {\n    let file_content = try read_file(\"config.json\");\n    let json_data = try parse_json(file_content);\n    let config = try Config::from_json(json_data);\n    return Ok(config);\n}\n```"}
{"input": "# Error Handling: Optional Type\n\nThe Optional (or Option) type in PyLang represents values that might be absent:\n\n```pylang\n// Option type definition\n// enum Option<T> {\n//     Some(T),\n//     None\n// }\n\n// Function that returns an Option\nfunc find_user(id: int) -> Option<User> {\n    if id == 42 {\n        return Some(User { name: \"Alice\", age: 30 })\n    }\n    return None\n}\n\n// Using Option with pattern matching\nlet user = find_user(42)\nmatch user {\n    Some(u) => print(\"Found user: ${u.name}\"),\n    None => print(\"User not found\")\n}\n\n// Using Option with if-let\nif let Some(user) = find_user(123) {\n    print(\"User: ${user.name}\")\n} else {\n    print(\"No user with that ID\")\n}\n\n// Methods on Option\nlet name = find_user(42)\n    .map(|user| user.name)  // Transform the contained value\n    .unwrap_or(\"Unknown\")   // Default value if None\n```"}
{"input": "# Structs\n\nStructs in PyLang are used to create custom data types with named fields:\n\n```pylang\n// Defining a struct\nstruct Point {\n    x: float,\n    y: float\n}\n\n// Creating struct instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet point = Point { x: 3.5, y: -2.0 }\n\n// Accessing fields\nprint(\"Point coordinates: (${point.x}, ${point.y})\")\n\n// Struct update syntax\nlet another_point = Point { y: 10.0, ..point }  // x is copied from point\n\n// Tuple structs (unnamed fields)\nstruct Color(int, int, int)  // RGB color\n\nlet red = Color(255, 0, 0)\nprint(\"Red value: ${red.0}\")\n\n// Unit structs (no fields)\nstruct UnitStruct\n```"}
{"input": "# Struct Methods\n\nStructs in PyLang can have associated methods defined in implementation blocks:\n\n```pylang\nstruct Rectangle {\n    width: float,\n    height: float\n}\n\nimpl Rectangle {\n    // Constructor method (by convention)\n    func new(width: float, height: float) -> Rectangle {\n        return Rectangle { width, height }\n    }\n    \n    // Instance method (takes self parameter)\n    func area(&self) -> float {\n        return self.width * self.height\n    }\n    \n    // Mutable method (can modify the instance)\n    func scale(&mut self, factor: float) {\n        self.width *= factor\n        self.height *= factor\n    }\n    \n    // Static method (doesn't take self parameter)\n    func square(size: float) -> Rectangle {\n        return Rectangle { width: size, height: size }\n    }\n}\n\n// Using the methods\nlet mut rect = Rectangle::new(5.0, 3.0)\nprint(\"Area: ${rect.area()}\")\n\nrect.scale(2.0)\nprint(\"Scaled area: ${rect.area()}\")\n\nlet square = Rectangle::square(4.0)\n```"}
{"input": "# Enums\n\nEnums in PyLang define types with a fixed set of variants:\n\n```pylang\n// Basic enum\nenum Direction {\n    North,\n    East,\n    South,\n    West\n}\n\nlet heading = Direction::North\n\n// Pattern matching on enums\nmatch heading {\n    Direction::North => print(\"Heading north\"),\n    Direction::East => print(\"Heading east\"),\n    Direction::South => print(\"Heading south\"),\n    Direction::West => print(\"Heading west\")\n}\n\n// Enum with associated values\nenum Shape {\n    Circle(float),            // radius\n    Rectangle(float, float),   // width, height\n    Triangle(float, float, float)  // three sides\n}\n\nlet shape = Shape::Rectangle(5.0, 3.0)\n\n// Pattern matching with destructuring\nmatch shape {\n    Shape::Circle(radius) => print(\"Circle with radius ${radius}\"),\n    Shape::Rectangle(width, height) => print(\"${width}x${height} rectangle\"),\n    Shape::Triangle(a, b, c) => print(\"Triangle with sides ${a}, ${b}, ${c}\")\n}\n```"}
{"input": "# Enum Methods\n\nLike structs, enums in PyLang can have methods defined in implementation blocks:\n\n```pylang\nenum Shape {\n    Circle(float),            // radius\n    Rectangle(float, float),   // width, height\n    Triangle(float, float, float)  // three sides\n}\n\nimpl Shape {\n    // Calculate the area of any shape\n    func area(&self) -> float {\n        match self {\n            Shape::Circle(radius) => {\n                return 3.14159 * radius * radius\n            },\n            Shape::Rectangle(width, height) => {\n                return width * height\n            },\n            Shape::Triangle(a, b, c) => {\n                // Heron's formula\n                let s = (a + b + c) / 2.0\n                return (s * (s - a) * (s - b) * (s - c)).sqrt()\n            }\n        }\n    }\n    \n    // Check if the shape is regular\n    func is_regular(&self) -> bool {\n        match self {\n            Shape::Circle(_) => true,  // All circles are regular\n            Shape::Rectangle(w, h) => w == h,  // Only squares are regular rectangles\n            Shape::Triangle(a, b, c) => a == b && b == c  // Only equilateral triangles\n        }\n    }\n}\n\nlet circle = Shape::Circle(2.0)\nprint(\"Circle area: ${circle.area()}, regular: ${circle.is_regular()}\")\n```"}
{"input": "# Traits\n\nTraits in PyLang define shared behavior that types can implement:\n\n```pylang\n// Define a trait\ntrait Printable {\n    // Required method (must be implemented)\n    func to_string(&self) -> string"}
{"input": "# Traits (continued)\n\nTraits in PyLang define shared behavior that types can implement:\n\n```pylang\n// Define a trait\ntrait Printable {\n    // Required method (must be implemented)\n    func to_string(&self) -> string;\n    \n    // Default method (implementation provided)\n    func print(&self) {\n        println(self.to_string());\n    }\n}\n\n// Implement the trait for a type\nstruct Person {\n    name: string,\n    age: int\n}\n\nimpl Printable for Person {\n    func to_string(&self) -> string {\n        return \"Person {name: ${self.name}, age: ${self.age}}\";\n    }\n    // No need to implement print() as it uses the default implementation\n}\n\n// Using the trait\nlet alice = Person { name: \"Alice\", age: 30 };\nalice.print();  // Uses the trait method\n```\n\nTraits enable polymorphism and code reuse across different types."}
{"input": "# Trait Bounds\n\nTrait bounds in PyLang constrain generic types to implement specific traits:\n\n```pylang\n// Generic function with trait bound\nfunc print_item<T: Printable>(item: T) {\n    item.print();\n}\n\n// Multiple trait bounds\nfunc process<T: Serializable + Printable>(item: T) {\n    // Can use both Serializable and Printable methods on item\n    let json = item.to_json();\n    item.print();\n}\n\n// Where clause for complex bounds\nfunc transform<T, U>(input: T) -> U\nwhere\n    T: Convertible<U>,\n    U: Sized + Clone\n{\n    return input.convert();\n}\n\n// Trait objects for dynamic dispatch\nfunc print_items(items: List<Box<dyn Printable>>) {\n    for item in items {\n        item.print();\n    }\n}\n```\n\nTrait bounds ensure that generic code only works with types that provide the required functionality."}
{"input": "# Generics\n\nGenerics in PyLang allow you to write flexible, reusable code with type parameters:\n\n```pylang\n// Generic struct\nstruct Pair<T, U> {\n    first: T,\n    second: U\n}\n\n// Creating instances with different types\nlet int_pair = Pair { first: 1, second: 2 };\nlet mixed_pair = Pair { first: \"hello\", second: 5 };\n\n// Generic function\nfunc swap<T>(a: T, b: T) -> (T, T) {\n    return (b, a);\n}\n\nlet (b, a) = swap(\"hello\", \"world\");\n\n// Generic implementation\nimpl<T, U> Pair<T, U> {\n    func new(first: T, second: U) -> Pair<T, U> {\n        return Pair { first, second };\n    }\n    \n    func first_value(&self) -> &T {\n        return &self.first;\n    }\n}\n\n// Generic with trait bounds\nfunc largest<T: Comparable>(list: &[T]) -> &T {\n    let mut largest = &list;\n    for item in list.iter().skip(1) {\n        if item > largest {\n            largest = item;\n        }\n    }\n    return largest;\n}\n```"}
{"input": "# Lifetimes\n\nLifetimes in PyLang ensure that references remain valid for as long as they're used:\n\n```pylang\n// Function with explicit lifetime annotations\nfunc longest<'a>(x: &'a string, y: &'a string) -> &'a string {\n    if x.len() > y.len() {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Struct with references needs lifetime annotations\nstruct TextBlock<'a> {\n    content: &'a string,\n    title: &'a string\n}\n\nimpl<'a> TextBlock<'a> {\n    func new(content: &'a string, title: &'a string) -> TextBlock<'a> {\n        return TextBlock { content, title };\n    }\n}\n\n// Multiple lifetime parameters\nfunc combine<'a, 'b>(first: &'a string, second: &'b string) -> string {\n    return first.clone() + second;\n}\n\n// Static lifetime\nlet PROGRAM_NAME: &'static string = \"MyApp\";\n```\n\nLifetimes help the compiler ensure memory safety without garbage collection."}
{"input": "# Ownership\n\nOwnership is a key concept in PyLang that manages memory safety:\n\n```pylang\n// Ownership basics\nfunc ownership_example() {\n    let s1 = \"hello\".to_string();  // s1 owns the string\n    let s2 = s1;  // Ownership moves to s2\n    \n    // print(s1);  // Error: s1 has been moved and is no longer valid\n    print(s2);  // Works fine\n    \n    let x = 5;  // Primitive types are copied, not moved\n    let y = x;  // Both x and y are valid\n    print(\"x = ${x}, y = ${y}\");  // Works fine\n}\n\n// Functions take ownership\nfunc take_ownership(s: string) {\n    print(\"Took: ${s}\");\n    // s is dropped here when function ends\n}\n\nfunc give_ownership() -> string {\n    let s = \"hello\".to_string();\n    return s;  // Ownership is transferred to caller\n}\n\n// Example usage\nlet s = give_ownership();\ntake_ownership(s);\n// Using s here would cause an error\n```\n\nOwnership rules help prevent memory errors and enable automatic memory management."}
{"input": "# Borrowing\n\nBorrowing in PyLang allows temporary access to data without transferring ownership:\n\n```pylang\n// Immutable borrowing\nfunc calculate_length(s: &string) -> int {\n    return s.len();  // s is borrowed, not owned\n}\n\nlet text = \"hello world\".to_string();\nlet length = calculate_length(&text);  // Borrow text\nprint(text);  // Still valid as ownership wasn't transferred\n\n// Mutable borrowing\nfunc append_world(s: &mut string) {\n    s.append(\" world\");\n}\n\nlet mut greeting = \"hello\".to_string();\nappend_world(&mut greeting);  // Mutable borrow\nprint(greeting);  // \"hello world\"\n\n// Borrowing rules\nlet mut s = \"hello\".to_string();\nlet r1 = &s;  // Immutable borrow\nlet r2 = &s;  // Multiple immutable borrows are allowed\n\n// let r3 = &mut s;  // Error: can't borrow as mutable while borrowed as immutable\n\nprint(\"${r1}, ${r2}\");\n\n// After r1 and r2 are no longer used, mutable borrow is allowed\nlet r3 = &mut s;  // Now allowed\n// print(r1);  // Error: r1 can't be used after mutable borrow\n```"}
{"input": "# Memory Management: Scopes and Dropping\n\nPyLang automatically frees memory when variables go out of scope:\n\n```pylang\nfunc scope_example() {\n    {\n        let inner = \"I'm in an inner scope\".to_string();\n        print(inner);  // Works fine\n    }  // inner is dropped here\n    \n    // print(inner);  // Error: inner is no longer valid\n    \n    let outer = \"I'm in the outer scope\".to_string();\n    print(outer);  // Works fine\n}  // outer is dropped here\n\n// The Drop trait controls what happens when a value is dropped\nstruct Resource {\n    name: string\n}\n\nimpl Drop for Resource {\n    func drop(&mut self) {\n        print(\"Cleaning up resource: ${self.name}\");\n    }\n}\n\nfunc resource_example() {\n    let res1 = Resource { name: \"database connection\".to_string() };\n    {\n        let res2 = Resource { name: \"file handle\".to_string() };\n        print(\"Using resources...\");\n    }  // res2.drop() is called here\n    print(\"Still using res1...\");\n}  // res1.drop() is called here\n```"}
{"input": "# Smart Pointers: Box\n\nBox in PyLang is a smart pointer for heap allocation:\n\n```pylang\n// Basic Box usage\nlet b = Box::new(5);  // Allocates 5 on the heap\nprint(\"Value: ${*b}\");  // Dereference with *\n\n// Enabling recursive data structures\nstruct Node {\n    value: int,\n    next: Option<Box<Node>>  // Self-referential structure\n}\n\n// Creating a linked list\nlet list = Node {\n    value: 1,\n    next: Some(Box::new(Node {\n        value: 2,\n        next: Some(Box::new(Node {\n            value: 3,\n            next: None\n        }))\n    }))\n};\n\n// Accessing nested values\nlet second_value = list.next.as_ref().unwrap().value;  // 2\n\n// Box for trait objects\nlet printable: Box<dyn Printable> = Box::new(Person { name: \"Bob\".to_string(), age: 25 });\nprintable.print();  // Uses dynamic dispatch\n```\n\nBox is useful for recursive types, trait objects, and ensuring data is on the heap."}
{"input": "# Smart Pointers: Rc\n\nRc (Reference Counting) allows multiple ownership of the same data:\n\n```pylang\nimport std::rc::Rc;\n\n// Creating a shared value\nlet data = Rc::new(\"Hello, world!\".to_string());\n\n// Creating multiple owners\nlet owner1 = data.clone();  // Increments the reference count\nlet owner2 = data.clone();  // Increments the reference count\n\nprint(\"Reference count: ${Rc::strong_count(&data)}\");  // 3\n\n// Shared ownership of complex structures\nstruct Node {\n    value: int,\n    children: List<Rc<Node>>\n}\n\n// Creating a tree structure\nlet leaf1 = Rc::new(Node { value: 2, children: List::new() });\nlet leaf2 = Rc::new(Node { value: 3, children: List::new() });\n\nlet root = Rc::new(Node {\n    value: 1,\n    children: List::from([leaf1.clone(), leaf2.clone()])\n});\n\n// Data is dropped when the last owner is dropped\ndrop(owner1);  // Reference count decreases to 2\nprint(\"Reference count: ${Rc::strong_count(&data)}\");  // 2\n```\n\nRc is useful for shared data structures but doesn't allow mutation by default."}
{"input": "# Smart Pointers: Arc\n\nArc (Atomic Reference Counting) enables thread-safe shared ownership:\n\n```pylang\nimport std::sync::Arc;\nimport std::thread;\n\n// Creating thread-safe shared data\nlet data = Arc::new(\"Hello from multiple threads!\".to_string());\n\nlet mut handles = List::new();\n\n// Spawn multiple threads that access the data\nfor id in 1..=3 {\n    let thread_data = data.clone();  // Increment reference count\n    \n    let handle = thread::spawn(move || {\n        print(\"Thread ${id}: ${thread_data}\");\n    });\n    \n    handles.push(handle);\n}\n\n// Wait for all threads to finish\nfor handle in handles {\n    handle.join().unwrap();\n}\n\nprint(\"Done!\");\n\n// Arc combined with Mutex for mutable shared state\nimport std::sync::Mutex;\n\nlet counter = Arc::new(Mutex::new(0));\nlet mut thread_handles = List::new();\n\nfor _ in 0..10 {\n    let counter_ref = counter.clone();\n    let handle = thread::spawn(move || {\n        let mut num = counter_ref.lock().unwrap();\n        *num += 1;\n    });\n    thread_handles.push(handle);\n}\n```"}
{"input": "# Concurrency: Threads\n\nPyLang provides native thread support for concurrent execution:\n\n```pylang\nimport std::thread;\nimport std::time;\n\n// Spawning a basic thread\nlet handle = thread::spawn(|| {\n    print(\"Hello from a thread!\");\n});\n\n// Wait for the thread to finish\nhandle.join().unwrap();\n\n// Threads with parameters using move closures\nlet data = vec![1, 2, 3];\n\nlet handle = thread::spawn(move || {\n    print(\"Thread has data: ${data}\");\n});\n\n// print(data);  // Error: data has been moved to the thread\n\nhandle.join().unwrap();\n\n// Multiple threads\nlet mut handles = List::new();\n\nfor i in 0..5 {\n    let handle = thread::spawn(move || {\n        print(\"Thread ${i} is running\");\n        thread::sleep(time::Duration::from_millis(100));\n        print(\"Thread ${i} is done\");\n    });\n    handles.push(handle);\n}\n\n// Wait for all threads\nfor handle in handles {\n    handle.join().unwrap();\n}\n```"}
{"input": "# Concurrency: Mutex and RwLock\n\nPyLang provides synchronization primitives for safe concurrent access to shared data:\n\n```pylang\nimport std::sync::{Mutex, RwLock, Arc};\nimport std::thread;\n\n// Mutex for exclusive access\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles = List::new();\n\nfor _ in 0..10 {\n    let counter_ref = counter.clone();\n    let handle = thread::spawn(move || {\n        // Lock the mutex to get exclusive access\n        let mut value = counter_ref.lock().unwrap();\n        *value += 1;\n        // Mutex is automatically unlocked when value goes out of scope\n    });\n    handles.push(handle);\n}\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n\nprint(\"Final count: ${*counter.lock().unwrap()}\");  // 10\n\n// RwLock for reader-writer access patterns\nlet data = Arc::new(RwLock::new(vec![1, 2, 3]));\n\n// Multiple readers can access simultaneously\nlet reader1 = data.clone();\nlet reader2 = data.clone();\n\nlet read_handle1 = thread::spawn(move || {\n    let values = reader1.read().unwrap();\n    print(\"Reader 1: ${values}\");\n});\n\nlet read_handle2 = thread::spawn(move || {\n    let values = reader2.read().unwrap();\n    print(\"Reader 2: ${values}\");\n});\n\n// Writers get exclusive access\nlet writer = data.clone();\nlet write_handle = thread::spawn(move || {\n    let mut values = writer.write().unwrap();\n    values.push(4);\n    print(\"Writer: ${values}\");\n});\n```"}
{"input": "# Concurrency: Channels\n\nChannels in PyLang allow communication between threads:\n\n```pylang\nimport std::sync::mpsc;\nimport std::thread;\nimport std::time::Duration;\n\n// Creating a channel\nlet (tx, rx) = mpsc::channel();\n\n// Sender thread\nlet sender_handle = thread::spawn(move || {\n    let messages = [\"Hello\", \"from\", \"the\", \"other\", \"thread\"];\n    \n    for msg in messages {\n        tx.send(msg).unwrap();\n        thread::sleep(Duration::from_millis(100));\n    }\n});\n\n// Receiver thread\nlet receiver_handle = thread::spawn(move || {\n    // Receiving individual messages\n    while let Ok(message) = rx.recv() {\n        print(\"Received: ${message}\");\n    }\n});\n\nsender_handle.join().unwrap();\nreceiver_handle.join().unwrap();\n\n// Multiple producers\nlet (tx, rx) = mpsc::channel();\n\nfor i in 0..5 {\n    let tx_clone = tx.clone();\n    thread::spawn(move || {\n        tx_clone.send(format(\"Message from thread ${i}\")).unwrap();\n    });\n}\n\n// Drop the original sender to close the channel after all clones are done\ndrop(tx);\n\n// Collect all messages\nwhile let Ok(message) = rx.recv() {\n    print(message);\n}\n```"}
{"input": "# Async/Await\n\nPyLang supports asynchronous programming with async/await syntax:\n\n```pylang\nimport std::async;\n\n// Defining an async function\nasync func fetch_data(url: string) -> Result<string, Error> {\n    print(\"Fetching ${url}...\");\n    // Simulate network request\n    await async::sleep(Duration::from_millis(100));\n    return Ok(format(\"Data from ${url}\"));\n}\n\n// Async functions can be composed\nasync func process_data(url: string) -> Result<string, Error> {\n    let data = await fetch_data(url)?;\n    print(\"Processing ${data}...\");\n    await async::sleep(Duration::from_millis(50));\n    return Ok(format(\"Processed ${data}\"));\n}\n\n// Running async code\nasync func main_async() {\n    let urls = [\"http://example.com/1\", \"http://example.com/2\"];\n    \n    // Sequential execution\n    for url in urls {\n        match await process_data(url) {\n            Ok(result) => print(result),\n            Err(e) => print(\"Error: ${e}\")\n        }\n    }\n    \n    // Parallel execution\n    let tasks: Vec<_> = urls\n        .map(|url| async::spawn(process_data(url)))\n        .collect();\n    \n    for task in tasks {\n        match await task {\n            Ok(Ok(result)) => print(result),\n            Ok(Err(e)) => print(\"Request error: ${e}\"),\n            Err(e) => print(\"Task error: ${e}\")\n        }\n    }\n}\n\n// Run the async function\nasync::Runtime::new().unwrap().block_on(main_async());\n```"}
{"input": "# Future and Stream\n\nPyLang's async ecosystem includes Future and Stream abstractions:\n\n```pylang\nimport std::future::Future;\nimport std::stream::Stream;\n\n// Working with Futures\nasync func future_example() {\n    // Creating a future\n    let future = async {\n        await async::sleep(Duration::from_millis(100));\n        return 42;\n    };\n    \n    // Awaiting a future\n    let result = await future;\n    print(\"Future result: ${result}\");\n    \n    // Combining futures\n    let f1 = async { return \"hello\"; };\n    let f2 = async { return \"world\"; };\n    \n    // Run futures concurrently and collect results\n    let (r1, r2) = async::join(f1, f2).await;\n    print(\"${r1} ${r2}\");\n}\n\n// Working with Streams\nasync func stream_example() {\n    // Creating a stream\n    let mut stream = async::stream::iter(1..=5);\n    \n    // Processing stream items\n    while let Some(item) = await stream.next() {\n        print(\"Stream item: ${item}\");\n    }\n    \n    // Stream transformations\n    let doubled = async::stream::iter(1..=5)\n        .map(|x| x * 2)\n        .filter(|x| x > 5);\n    \n    // Collecting stream results\n    let results: Vec<_> = await doubled.collect();\n    print(\"Collected: ${results}\");\n}\n```"}
{"input": "# Pattern Matching: Destructuring\n\nPyLang's pattern matching supports complex destructuring:\n\n```pylang\n// Destructuring tuples\nlet point = (10, 20);\nlet (x, y) = point;\nprint(\"x: ${x}, y: ${y}\");\n\n// Destructuring structs\nstruct Person {\n    name: string,\n    age: int\n}\n\nlet person = Person { name: \"Alice\".to_string(), age: 30 };\nlet Person { name, age } = person;\nprint(\"${name} is ${age} years old\");\n\n// Destructuring with match\nlet value = (\"hello\", 42);\n\nmatch value {\n    (\"hello\", n) => print(\"Hello with ${n}\"),\n    (\"bye\", n) => print(\"Goodbye with ${n}\"),\n    _ => print(\"Something else\")\n}\n\n// Nested destructuring\nlet nested = ((1, 2), (3, 4));\n\nmatch nested {\n    ((a, b), (c, d)) => print(\"Values: ${a}, ${b}, ${c}, ${d}\")\n}\n\n// Destructuring with guards\nlet pair = (3, 4);\n\nmatch pair {\n    (x, y) if x == y => print(\"Equal coordinates\"),\n    (x, y) if x > y => print(\"x is greater\"),\n    (x, y) => print(\"y is greater\")\n}\n```"}
{"input": "# Pattern Matching: Advanced Features\n\nPyLang offers advanced pattern matching capabilities:\n\n```pylang\n// Range patterns\nlet x = 5;\n\nmatch x {\n    1..=5 => print(\"1 to 5\"),\n    6..=10 => print(\"6 to 10\"),\n    _ => print(\"something else\")\n}\n\n// Multiple patterns\nmatch x {\n    1 | 3 | 5 | 7 | 9 => print(\"Odd number from 1-9\"),\n    2 | 4 | 6 | 8 => print(\"Even number from 2-8\"),\n    _ => print(\"Out of range\")\n}\n\n// Binding with @ pattern\nmatch x {\n    n @ 1..=5 => print(\"${n} is between 1 and 5\"),\n    n @ 6..=10 => print(\"${n} is between 6 and 10\"),\n    n => print(\"${n} is outside ranges\")\n}\n\n// Pattern matching with Option\nlet maybe_value: Option<int> = Some(42);\n\nmatch maybe_value {\n    Some(n) if n > 100 => print(\"Large number\"),\n    Some(n) => print(\"Got ${n}\"),\n    None => print(\"No value\")\n}\n\n// Pattern matching with Result\nlet result: Result<int, string> = Ok(42);\n\nmatch result {\n    Ok(n) => print(\"Success: ${n}\"),\n    Err(e) => print(\"Error: ${e}\")\n}\n```"}
{"input": "# Modules and Imports\n\nPyLang organizes code into modules and packages:\n\n```pylang\n// File: math_utils.pyl\nmodule math_utils;\n\npublic func add(a: int, b: int) -> int {\n    return a + b;\n}\n\npublic func subtract(a: int, b: int) -> int {\n    return a - b;\n}\n\n// Private function (not accessible outside this module)\nfunc helper() -> string {\n    return \"I'm a helper function\";\n}\n\n// File: main.pyl\nimport math_utils;  // Import the entire module\n\nfunc main() {\n    let sum = math_utils::add(5, 3);\n    print(\"Sum: ${sum}\");\n}\n\n// Selective imports\nimport math_utils::{add, subtract};\n\nfunc calculate() {\n    let sum = add(10, 5);  // Directly use add without module prefix\n    let diff = subtract(10, 5);\n}\n\n// Renaming imports\nimport math_utils::add as addition;\n\nfunc renamed() {\n    let result = addition(7, 8);  // Using the renamed import\n}\n```"}
{"input": "# Packages and Project Structure\n\nPyLang organizes code into packages with a defined structure:\n\n```\nmy_project/\n├── Pylfile.toml      # Project configuration file\n├── src/\n│   ├── main.pyl      # Entry point\n│   ├── lib.pyl       # Library exports\n│   ├── utils/        # Submodule directory\n│   │   ├── mod.pyl   # Submodule definition\n│   │   ├── io.pyl    # IO utilities\n│   │   └── math.pyl  # Math utilities\n│   └── models/       # Another submodule\n│       ├── mod.pyl   # Submodule definition\n│       └── user.pyl  # User model\n└── tests/            # Test directory\n    └── test_utils.pyl\n```\n\n```pylang\n// File: src/lib.pyl\nmodule my_project;\n\n// Re-export submodules\npublic import utils;\npublic import models;\n\n// Public API\npublic func version() -> string {\n    return \"1.0.0\";\n}\n\n// File: src/utils/mod.pyl\nmodule my_project::utils;\n\n// Re-export specific items from submodules\npublic import io::{read_file, write_file};\npublic import math::calculate;\n\n// File: src/main.pyl\nimport my_project::{utils, models, version};\n\nfunc main() {\n    print(\"Version: ${version()}\");\n    let data = utils::read_file(\"config.json\");\n    let user = models::User::from_json(data);\n}\n```"}
{"input": "# Error Handling: Custom Errors\n\nPyLang allows defining custom error types:\n\n```pylang\n// Define a custom error type\nenum AppError {\n    IoError(std::io::Error),\n    ParseError { line: int, message: string },\n    ValidationError(string),\n    NotFound\n}\n\n// Implement standard error traits\nimpl std::error::Error for AppError {}\n\nimpl Display for AppError {\n    func fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            AppError::IoError(e) => write!(f, \"IO error: ${e}\"),\n            AppError::ParseError { line, message } => write!(f, \"Parse error at line ${line}: ${message}\"),\n            AppError::ValidationError(msg) => write!(f, \"Validation failed: ${msg}\"),\n            AppError::NotFound => write!(f, \"Resource not found\")\n        }\n    }\n}\n\n// Convert from standard error types\nimpl From<std::io::Error> for AppError {\n    func from(error: std::io::Error) -> Self {\n        return AppError::IoError(error);\n    }\n}\n\n// Function that returns the custom error\nfunc process_file(path: string) -> Result<string, AppError> {\n    // The ? operator works with our custom error type\n    let content = std::fs::read_to_string(path)?;  // IoError is automatically converted\n    \n    if content.is_empty() {\n        return Err(AppError::ValidationError(\"File is empty\".to_string()));\n    }\n    \n    // More processing...\n    return Ok(content);\n}\n```"}
{"input": "# Unit Testing\n\nPyLang has built-in support for unit testing:\n\n```pylang\nmodule math;\n\npublic func add(a: int, b: int) -> int {\n    return a + b;\n}\n\npublic func subtract(a: int, b: int) -> int {\n    return a - b;\n}\n\n#[test]  // Test module with test functions\nmodule tests {\n    import super::*;  // Import from parent module\n    \n    #[test]  // Test function annotation\n    func test_add() {\n        assert_eq(add(2, 3), 5);\n        assert_eq(add(0, 0), 0);\n        assert_eq(add(-1, 1), 0);\n    }\n    \n    #[test]\n    func test_subtract() {\n        assert_eq(subtract(5, 2), 3);\n        assert_eq(subtract(0, 0), 0);\n        assert_eq(subtract(1, 1), 0);\n    }\n    \n    #[test]\n    #[should_panic]  // Test expected to panic\n    func test_panic() {\n        let x = [1, 2, 3];\n        let _ = x;  // This will panic\n    }\n    \n    #[test]\n    func test_with_description() {\n        let result = add(2, 2);\n        assert_eq(result, 4, \"2 + 2 should equal 4\");\n    }\n}\n\n// Run tests with: pylc test\n```"}
{"input": "# Integration Testing\n\nPyLang supports integration tests across modules:\n\n```pylang\n// File: tests/integration_tests.pyl\nmodule tests;\n\nimport my_project::utils;\nimport my_project::models;\n\n#[test]\nfunc test_user_creation() {\n    // Test that involves multiple modules\n    let data = utils::read_file(\"test_data/user.json\");\n    let user = models::User::from_json(data);\n    \n    assert_eq(user.name"}